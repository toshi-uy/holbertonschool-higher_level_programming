# holbertonschool-higher_level_programming
### Foundations - Higher-level programming ― Python

A  _**h**igh-**l**evel  **l**anguage_  (**HLL**) is a  programming language such as  C, FORTRAN, or Pascal that enables a programmer to write programs that are more or less independent of a particular type of  computer. Such languages are considered high-level because they are closer to human languages and further from machine languages.

In contrast, assembly languages are considered low-level because they are very close to machine languages.

![High Level Language](https://www.webopedia.com/wp-content/uploads/2020/10/high-level-language_5f854099c5060-2.gif)

## ADVANTAGES OF HIGH-LEVEL LANGUAGES

The main advantage of high-level languages over low-level languages is that they are easier to read, write, and maintain. Ultimately, programs written in a high-level language must be translated into machine language by a compiler or interpreter.

The first high-level programming languages were designed in the 1950s. Now there are dozens of different languages, including Ada, Algol, BASIC, COBOL, C, C++, FORTRAN, LISP, Pascal, and  Prolog.

## HIGH-LEVEL VS. LOW-LEVEL LANGUAGES

Low-level languages require little interpretation by the computer. This makes machine code fast compared to other programming languages. Low-level languages gives programmers more control over data storage, memory, and computer hardware. It’s typically used to write kernel or driver software. It wouldn’t be used to write web applications or games.

In contrast, high-level languages are easier to grasp. It allows a programmer to write code more efficiently. High-level languages have more safeguards to keep coders from issues commands that could potentially damage a computer. These languages don’t give programmers as much control as low-level ones do.

Here are some main differences between high and low-level languages:

High Level Language | Low Level Language
------------ | -------------
Programmer friendly | Machine friendly
Less memory efficient | Highly memory efficient
Easy to understand for programmers | Tough to understand for programmers
Simple to debug | Complex to debug comparatively
Simple to maintain | Complex to maintain comparatively
Portable | Non-portable
Can run on any platform | Machine-dependent
Needs compiler or interpreter for translation | Needs assembler for translation
Widely used for programming | Not commonly used in programming
